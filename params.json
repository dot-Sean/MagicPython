{"name":"MagicPython","tagline":"Syntax highlighter for cutting edge Python for Sublime Text and Atom.","body":"This is a package with preferences and syntax highlighter for cutting edge\r\nPython 3 (although Python 2 is well supported too). The syntax is compatible\r\nwith [Sublime Text](http://www.sublimetext.com) and [Atom](http://atom.io).\r\nIt is meant to be a drop-in replacement for the default Python package.\r\n\r\n\r\n## Screenshot\r\n\r\n![](https://magicstack.github.io/MagicPython/example.png)\r\n\r\n\r\n## Installation Instructions\r\n\r\nThis is meant to be a drop-in replacement for the default Python package.\r\n\r\nIn **Atom**, install the `MagicPython` package and disable the built-in\r\n`language-python` package.\r\n\r\nIn **Sublime Text**, install `MagicPython` package via \"Package Control\" and\r\ndisable the built-in `Python` package (using\r\n`Package Control -> Disable Package`, or directly by adding `\"Python\"` to\r\n`\"ignored_packages\"` in the settings file).\r\n\r\nAlternatively, the package can be installed manually in both editors:\r\n\r\n- copy the MagicPython package into the Sublime/Atom user packages directory;\r\n- disable Python package;\r\n- enjoy.\r\n\r\n\r\n## Changes and Improvements\r\n\r\nThe main motivation behind this package was the difficulty of using modern\r\nPython with other common syntax highlighters. They do a good job of the 90% of\r\nthe language, but then fail on the nuances of some very useful, but often\r\noverlooked features. Function annotations tend to freak out the highlighters in\r\nvarious ways. Newly introduced keywords and magic methods are slow to be\r\nintegrated. Another issue is string highlighting, where all raw strings are\r\noften assumed to be regular expressions or special markup used by `.format` is\r\ncompletely ignored. Bumping into all of these issues on daily basis eventually\r\nled to the creation of this package.\r\n\r\nOverall, the central idea is that it should be easy to notice something odd or\r\nspecial about the code. Odd or special doesn't necessarily mean incorrect, but\r\ncertainly worth the explicit attention.\r\n\r\n\r\n### Annotations\r\n\r\nAnnotations should not break the highlighting. They should be no more difficult\r\nto read at a glance than other code or comments.\r\n\r\nA typical case is having a string annotation that spans several lines by using\r\nimplicit string concatenation. Multi-line strings are suboptimal for use in\r\nannotations as it may be highly undesirable to have odd indentation and extra\r\nwhitespace in the annotation string. Of course, there is no problem using line\r\ncontinuation or even having comments mixed in with implicit string\r\nconcatenation. All of these will be highlighted as you'd expect in any other\r\nplace in the code.\r\n\r\n```python\r\ndef some_func(a,                        # nothing fancy here, yet\r\n\r\n              b: 'Annotation: '         # implicitly\r\n                 '\"foo\" for Foo, '      # concatenated\r\n                 '\"bar\" for Bar, '      # annotation\r\n                 '\"other\" otherwise'='otherwise'):\r\n```\r\n\r\nA more advanced use case for annotations is to actually have complex expressions\r\nin them, such as lambda functions, tuples, lists, dicts, sets, comprehensions.\r\nAdmittedly, all of these might be less frequently used, but when they are, you\r\ncan rely on them being highlighted normally in all their glorious details.\r\n\r\n```python\r\n# no reason why this should cause the highlighter to break\r\n#\r\ndef some_func(a:\r\n                 # annotation starts here\r\n                 lambda x=None:\r\n                    {key: val\r\n                        for key, val in\r\n                            (x if x is not None else [])\r\n                    }\r\n                    # annotation ends here and below is the default for 'a'\r\n                    =42):\r\n```\r\n\r\nResult annotations are handled as any other expression would be. No reason to\r\nworry that the body of the function would look messed up.\r\n\r\n```python\r\n# no reason why this should cause the highlighter to break\r\n#\r\ndef some_func() -> {\r\n                     'Some',        # comments\r\n                     'valid',       # are\r\n                     'expression'   # good\r\n                   }:\r\n```\r\n\r\n\r\n### Strings\r\n\r\nStrings are used in many different ways for processing and presenting data.\r\nMaking the highlighter more friendly towards these uses can help you concentrate\r\nyour efforts on what matters rather than visual parsing.\r\n\r\nRaw strings are often interpreted as regular expressions. This is a bit of a\r\nproblem, because depending on the application this may actually not be the most\r\ncommon case. Raw strings can simply be the input to some other processor, in\r\nwhich case regexp-specific highlighting is really hindering the overall\r\nreadability. MagicPython follows a convention that a lower-case `r` prefix means\r\na regexp string, but an upper-case `R` prefix means just a raw string with no\r\nspecial regexp semantics. This convention holds true for all of the legal\r\ncombinations of prefixes. As always the syntax is biased towards Python 3, thus\r\nit will mark Pyhton-2-only prefixes (i.e. variations of `ur`) as deprecated.\r\n\r\nString formatting is often only supported for '%-style formatting', however, the\r\nrecommended and more readable syntax used by `.format` is ignored. The benefits\r\nof using simple and readable `{key}` replacement fields are hindered by the fact\r\nthat in a complex or long string expression it may not be easily apparent what\r\nparameters will actually be needed by `.format`. This is why MagicPyhton\r\nhighlights both kinds of string formatting syntax within the appropriate string\r\ntypes (bytes don't have a `.format` method in Python 3, so they don't get the\r\nspecial highlighting for it, raw and unicode strings do). Additionally, the\r\nhighlighter also validates that the formatting is following the correct syntax.\r\nIt can help noticing an error in complex formatting expressions early.\r\n\r\n\r\n### Numeric literals\r\n\r\nMost numbers are just regular decimal constants, but any time that octal,\r\nbinary, hexadecimal or complex numbers are used it's worth noting that they are\r\nof a special type. Highlighting of Python 2 'L' integers is also supported.\r\n\r\n\r\n### Python 3.5 features\r\n\r\nNew keywords `async` and `await` are properly highlighted. Currently, these\r\nkeywords are new and are not yet reserved, so the Python interpreter will allow\r\nusing them as variable names. However, `async` and `await` are not recommended\r\nto be used as variable, class, function or module names. Introduced by\r\n[PEP 492](https://www.python.org/dev/peps/pep-0492/) in Python 3.5, they will\r\nbecome proper keywords in Python 3.7. It is very important that the highlighter\r\nshows their proper status when they are used as function parameter names, as\r\nthat could otherwise be unnoticed and lead to very messy debugging down the\r\nroad.\r\n\r\n\r\n### Built-ins and Magic Methods\r\n\r\nVarious built-in types, classes, functions, as well as magic methods are all\r\nhighlighted. Specifically, they are highlighted when they appear as names in\r\nuser definitions. Although it is not an error to have classes and functions that\r\nmask the built-ins, it is certainly worth drawing attention to, so that masking\r\nbecomes a deliberate rather than accidental act.\r\n\r\nHighlighting built-ins in class inheritance list makes it slightly more obvious\r\nwhere standard classes are extended. It is also easier to notice some typos\r\n(have you ever typed `Excepiton`?) a little earlier.\r\n\r\n\r\n### Parameters and Arguments\r\n\r\nMagicPython highlights keywords when they are used as parameter/argument names.\r\nThis was mentioned for the case of `async` and `await`, but it holds true for\r\nall other keywords. Although the Python interpreter will produce an appropriate\r\nerror message when reserved keywords are used as identifier names, it's still\r\nworth showing them early, to spare even this small debugging effort.\r\n\r\n## Development\r\n\r\nYou need `npm` and `node.js` to work on MagicPython.\r\n\r\n- clone the repository\r\n- run `make` to build the local development environment\r\n- run `make release` to build the syntax packages for Sublime Text and Atom\r\n  (running `make test` also generates the \"release\" packages)\r\n\r\nPlease note that we have some unit tests for the syntax scoping. We will be\r\nexpanding and updating our test corpus. This allows us to trust that tiny\r\ninconsistencies will not easily creep in as we update the syntax and fix bugs.\r\nUse `make test` to run the tests regularly while updating the syntax spec.\r\nCurrently the test files have two parts to them, separated by 3 empty newlines:\r\nthe code to be scoped and the spec that the result must match.\r\n\r\nIf you intend to submit a pull request, please follow the following guidelines:\r\n\r\n- keep code lines under 80 characters in length, it improves readability\r\n- please _do_ use multi-line regular expressions for any non-trivial cases like:\r\n\r\n    + the regexp contains a mix of escaped and unescaped braces/parentheses\r\n    + the regexp has several `|` in it\r\n    + the regexp has several pairs of parentheses, especially nested ones\r\n    + or the regexp is simply longer than 35 characters\r\n\r\n- always run `make test` to ensure that your changes didn't have unexpected side\r\n  effects\r\n- update unit tests and add new ones if needed, keeping the test cases short\r\n  whenever possible\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}